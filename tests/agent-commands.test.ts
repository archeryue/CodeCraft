import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { Agent } from '../src/agent';
import * as path from 'path';

// Mock fs module - use importOriginal to get all the real methods,
// then override only the ones we need to control
vi.mock('fs', async (importOriginal) => {
  const actual = await importOriginal();
  return {
    ...(actual as any),
    writeFileSync: vi.fn(),
    existsSync: vi.fn().mockReturnValue(false),
    readFileSync: vi.fn()
  };
});

// Mock analysis tools
vi.mock('../src/tools/detect-project-type', () => ({
  detectProjectTypeTool: {
    execute: vi.fn()
  }
}));

vi.mock('../src/tools/extract-conventions', () => ({
  extractConventionsTool: {
    execute: vi.fn()
  }
}));

vi.mock('../src/tools/get-project-overview', () => ({
  getProjectOverviewTool: {
    execute: vi.fn()
  }
}));

// Reuse the mock setup
const mockChat = {
  sendMessage: vi.fn().mockResolvedValue({
    response: {
      text: () => "Response",
      functionCalls: () => []
    }
  })
};

const mockModel = {
  startChat: vi.fn().mockReturnValue(mockChat)
};

const mockGenAI = {
  getGenerativeModel: vi.fn().mockReturnValue(mockModel)
};

vi.mock('@google/generative-ai', async (importOriginal) => {
  const actual = await importOriginal();
  return {
    ...(actual as any),
    GoogleGenerativeAI: class {
        constructor() { return mockGenAI; }
    }
  };
});

describe('Agent Commands', () => {
  it('should handle /clear command', async () => {
    const agent = new Agent('key');
    agent.start();

    console.log("Testing /clear...");
    const response = await agent.chat('/clear');

    expect(response).toBe('Context cleared.');
  });

  it('should handle /help command', async () => {
      const agent = new Agent('key');
      agent.start();
      const response = await agent.chat('/help');
      expect(response).toContain('/clear');
      expect(response).toContain('/help');
  });
});

describe('Agent /init Command', () => {
  let agent: Agent;
  let mockDetectProjectType: any;
  let mockExtractConventions: any;
  let mockGetProjectOverview: any;

  beforeEach(async () => {
    const fs = await import('fs');
    vi.mocked(fs.writeFileSync).mockClear().mockImplementation(() => {}); // Reset to default
    vi.mocked(fs.existsSync).mockClear().mockReturnValue(false); // Reset to default

    // Get mocked tools
    const { detectProjectTypeTool } = await import('../src/tools/detect-project-type');
    const { extractConventionsTool } = await import('../src/tools/extract-conventions');
    const { getProjectOverviewTool } = await import('../src/tools/get-project-overview');

    mockDetectProjectType = vi.mocked(detectProjectTypeTool.execute);
    mockExtractConventions = vi.mocked(extractConventionsTool.execute);
    mockGetProjectOverview = vi.mocked(getProjectOverviewTool.execute);

    // Reset all mocks
    mockDetectProjectType.mockClear();
    mockExtractConventions.mockClear();
    mockGetProjectOverview.mockClear();

    // Default success responses
    mockDetectProjectType.mockResolvedValue({
      success: true,
      data: { type: 'node', typescript: true }
    });
    mockExtractConventions.mockResolvedValue({
      success: true,
      data: { indent: '2 spaces', naming: 'camelCase' }
    });
    mockGetProjectOverview.mockResolvedValue({
      success: true,
      data: { name: 'Test Project' }
    });

    agent = new Agent('test-key');
    agent.start();
  });

  // Happy Path Tests
  it('should execute /init and return success message', async () => {
    const response = await agent.chat('/init');

    expect(response).toContain('Project analysis complete');
    expect(response).toContain('CRAFT.md');
    expect(mockDetectProjectType).toHaveBeenCalledWith({ path: '.' }, expect.anything());
    expect(mockExtractConventions).toHaveBeenCalledWith({ path: '.' }, expect.anything());
    expect(mockGetProjectOverview).toHaveBeenCalledWith({ path: '.' }, expect.anything());
  });

  it('should create CRAFT.md with correct structure', async () => {
    const fs = await import('fs');

    await agent.chat('/init');

    expect(fs.writeFileSync).toHaveBeenCalledTimes(1);

    const callArgs = vi.mocked(fs.writeFileSync).mock.calls[0];
    const filePath = callArgs[0];
    const content = callArgs[1];

    // Check file path
    expect(filePath).toContain('CRAFT.md');

    // Check content structure
    expect(content).toContain('# CRAFT.md - CodeCraft Project Analysis');
    expect(content).toContain('## Project Overview');
    expect(content).toContain('## Technology Stack');
    expect(content).toContain('## Code Conventions');
    expect(content).toContain('Generated by CodeCraft /init command');
  });

  it('should call all three analysis tools', async () => {
    await agent.chat('/init');

    expect(mockDetectProjectType).toHaveBeenCalledTimes(1);
    expect(mockExtractConventions).toHaveBeenCalledTimes(1);
    expect(mockGetProjectOverview).toHaveBeenCalledTimes(1);
  });

  // Edge Cases
  it('should handle existing CRAFT.md (overwrite)', async () => {
    const fs = await import('fs');
    const mockExecuteTool = vi.spyOn(agent as any, 'executeTool');
    mockExecuteTool.mockResolvedValue('new data');

    // Simulate existing file
    vi.mocked(fs.existsSync).mockReturnValue(true);

    const response = await agent.chat('/init');

    expect(response).toContain('Project analysis complete');
    expect(fs.writeFileSync).toHaveBeenCalled(); // Should still write
  });

  it('should handle /init with extra arguments (ignore them)', async () => {
    const response = await agent.chat('/init some extra args');

    // Should execute normally, ignoring extra args
    expect(response).toContain('Project analysis complete');
    expect(response).toContain('CRAFT.md');
    // Verify all three analysis tools were called
    expect(mockDetectProjectType).toHaveBeenCalled();
    expect(mockExtractConventions).toHaveBeenCalled();
    expect(mockGetProjectOverview).toHaveBeenCalled();
  });

  // Error Handling
  it('should handle tool execution failure gracefully', async () => {
    const fs = await import('fs');
    vi.mocked(fs.writeFileSync).mockClear();

    // Mock one of the tools to return an error
    mockDetectProjectType.mockResolvedValue({
      success: false,
      error: { code: 'TOOL_ERROR', message: 'Tool execution failed' }
    });

    const response = await agent.chat('/init');

    expect(response).toContain('Error generating CRAFT.md');
    expect(response).toContain('Tool execution failed');
    expect(fs.writeFileSync).not.toHaveBeenCalled(); // Should not write on error
  });

  it('should handle filesystem write error gracefully', async () => {
    const fs = await import('fs');

    // Mock fs.writeFileSync to throw error
    vi.mocked(fs.writeFileSync).mockImplementation(() => {
      throw new Error('EACCES: permission denied');
    });

    const response = await agent.chat('/init');

    expect(response).toContain('Error generating CRAFT.md');
    expect(response).toContain('permission denied');
  });

  it('should handle empty tool responses', async () => {
    const fs = await import('fs');
    vi.mocked(fs.writeFileSync).mockClear().mockImplementation(() => {});

    // Mock tools to return empty data
    mockDetectProjectType.mockResolvedValue({ success: true, data: {} });
    mockExtractConventions.mockResolvedValue({ success: true, data: {} });
    mockGetProjectOverview.mockResolvedValue({ success: true, data: {} });

    const response = await agent.chat('/init');

    expect(response).toContain('Project analysis complete');
    expect(fs.writeFileSync).toHaveBeenCalled();

    const content = vi.mocked(fs.writeFileSync).mock.calls[0][1];
    // Should still create valid structure even with empty data
    expect(content).toContain('## Project Overview');
  });

  // Integration Tests
  it('should format JSON tool responses correctly in CRAFT.md', async () => {
    const fs = await import('fs');
    vi.mocked(fs.writeFileSync).mockClear().mockImplementation(() => {});

    // Mock tools to return structured data
    mockDetectProjectType.mockResolvedValue({
      success: true,
      data: { language: 'TypeScript', framework: 'Node.js' }
    });
    mockExtractConventions.mockResolvedValue({
      success: true,
      data: { indent: '2 spaces', naming: 'camelCase' }
    });
    mockGetProjectOverview.mockResolvedValue({
      success: true,
      data: { name: 'CodeCraft', description: 'AI coding agent' }
    });

    await agent.chat('/init');

    const content = vi.mocked(fs.writeFileSync).mock.calls[0][1];

    // Should not contain "[object Object]"
    expect(content).not.toContain('[object Object]');

    // Should contain actual JSON data (serialized as JSON strings)
    expect(content).toContain('TypeScript');
    expect(content).toContain('camelCase');
    expect(content).toContain('CodeCraft');
  });

  it('should include timestamp in CRAFT.md', async () => {
    const fs = await import('fs');
    vi.mocked(fs.writeFileSync).mockClear().mockImplementation(() => {});

    await agent.chat('/init');

    const content = vi.mocked(fs.writeFileSync).mock.calls[0][1];

    expect(content).toMatch(/Generated by CodeCraft \/init command on \d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/);
  });

  it('should update /help to include /init command', async () => {
    const response = await agent.chat('/help');

    expect(response).toContain('/init');
  });
});
