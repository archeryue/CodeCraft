import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { Agent } from '../src/agent';
import * as path from 'path';

// Mock fs module - use importOriginal to get all the real methods,
// then override only the ones we need to control
vi.mock('fs', async (importOriginal) => {
  const actual = await importOriginal();
  return {
    ...(actual as any),
    writeFileSync: vi.fn(),
    existsSync: vi.fn().mockReturnValue(false),
    readFileSync: vi.fn()
  };
});

// Mock analysis functions
vi.mock('../src/analysis/index', () => ({
  detectProjectType: vi.fn(),
  extractConventions: vi.fn(),
  getProjectOverview: vi.fn()
}));

// Reuse the mock setup
const mockChat = {
  sendMessage: vi.fn().mockResolvedValue({
    response: {
      text: () => "Response",
      functionCalls: () => []
    }
  })
};

const mockModel = {
  startChat: vi.fn().mockReturnValue(mockChat)
};

const mockGenAI = {
  getGenerativeModel: vi.fn().mockReturnValue(mockModel)
};

vi.mock('@google/generative-ai', async (importOriginal) => {
  const actual = await importOriginal();
  return {
    ...(actual as any),
    GoogleGenerativeAI: class {
        constructor() { return mockGenAI; }
    }
  };
});

describe('Agent Commands', () => {
  it('should handle /clear command', async () => {
    const agent = new Agent('key');
    agent.start();

    console.log("Testing /clear...");
    const response = await agent.chat('/clear');

    expect(response).toBe('Context cleared.');
  });

  it('should handle /help command', async () => {
      const agent = new Agent('key');
      agent.start();
      const response = await agent.chat('/help');
      expect(response).toContain('/clear');
      expect(response).toContain('/help');
  });
});

describe('Agent /init Command', () => {
  let agent: Agent;
  let mockDetectProjectType: any;
  let mockExtractConventions: any;
  let mockGetProjectOverview: any;

  beforeEach(async () => {
    const fs = await import('fs');
    vi.mocked(fs.writeFileSync).mockClear().mockImplementation(() => {}); // Reset to default
    vi.mocked(fs.existsSync).mockClear().mockReturnValue(false); // Reset to default

    // Get mocked functions
    const analysis = await import('../src/analysis/index');

    mockDetectProjectType = vi.mocked(analysis.detectProjectType);
    mockExtractConventions = vi.mocked(analysis.extractConventions);
    mockGetProjectOverview = vi.mocked(analysis.getProjectOverview);

    // Reset all mocks
    mockDetectProjectType.mockClear();
    mockExtractConventions.mockClear();
    mockGetProjectOverview.mockClear();

    // Default success responses (now functions return data directly)
    mockDetectProjectType.mockReturnValue({
      type: 'node',
      typescript: true,
      testFramework: 'vitest',
      linter: 'eslint',
      packageManager: 'npm'
    });
    mockExtractConventions.mockResolvedValue({
      functionNaming: 'camelCase',
      classNaming: 'PascalCase',
      constantNaming: 'UPPER_SNAKE_CASE',
      indentStyle: 'spaces',
      indentSize: 2,
      quoteStyle: 'single',
      useSemicolons: true,
      testLocation: 'tests',
      testPattern: '.test.ts'
    });
    mockGetProjectOverview.mockReturnValue({
      purpose: 'Test Project',
      techStack: { name: 'test', languages: ['TypeScript'] },
      entryPoints: ['index.ts'],
      sources: ['package.json']
    });

    agent = new Agent('test-key');
    agent.start();
  });

  // Happy Path Tests
  it('should execute /init and return success message', async () => {
    const response = await agent.chat('/init');

    expect(response).toContain('Project analysis complete');
    expect(response).toContain('CRAFT.md');
    expect(mockDetectProjectType).toHaveBeenCalledWith('.');
    expect(mockExtractConventions).toHaveBeenCalledWith('.');
    expect(mockGetProjectOverview).toHaveBeenCalledWith('.');
  });

  it('should create CRAFT.md with correct structure', async () => {
    const fs = await import('fs');

    await agent.chat('/init');

    expect(fs.writeFileSync).toHaveBeenCalledTimes(1);

    const callArgs = vi.mocked(fs.writeFileSync).mock.calls[0];
    const filePath = callArgs[0];
    const content = callArgs[1];

    // Check file path
    expect(filePath).toContain('CRAFT.md');

    // Check content structure
    expect(content).toContain('# CRAFT.md - CodeCraft Project Analysis');
    expect(content).toContain('## Project Overview');
    expect(content).toContain('## Technology Stack');
    expect(content).toContain('## Code Conventions');
    expect(content).toContain('Generated by CodeCraft /init command');
  });

  it('should call all three analysis functions', async () => {
    await agent.chat('/init');

    expect(mockDetectProjectType).toHaveBeenCalledTimes(1);
    expect(mockExtractConventions).toHaveBeenCalledTimes(1);
    expect(mockGetProjectOverview).toHaveBeenCalledTimes(1);
  });

  // Edge Cases
  it('should handle existing CRAFT.md (overwrite)', async () => {
    const fs = await import('fs');

    // Simulate existing file
    vi.mocked(fs.existsSync).mockReturnValue(true);

    const response = await agent.chat('/init');

    expect(response).toContain('Project analysis complete');
    expect(fs.writeFileSync).toHaveBeenCalled(); // Should still write
  });

  it('should handle /init with extra arguments (ignore them)', async () => {
    const response = await agent.chat('/init some extra args');

    // Should execute normally, ignoring extra args
    expect(response).toContain('Project analysis complete');
    expect(response).toContain('CRAFT.md');
    // Verify all three analysis functions were called
    expect(mockDetectProjectType).toHaveBeenCalled();
    expect(mockExtractConventions).toHaveBeenCalled();
    expect(mockGetProjectOverview).toHaveBeenCalled();
  });

  // Error Handling
  it('should handle function execution failure gracefully', async () => {
    const fs = await import('fs');
    vi.mocked(fs.writeFileSync).mockClear();

    // Mock one of the functions to throw an error
    mockDetectProjectType.mockImplementation(() => {
      throw new Error('Detection failed');
    });

    const response = await agent.chat('/init');

    expect(response).toContain('Error generating CRAFT.md');
    expect(response).toContain('Detection failed');
    expect(fs.writeFileSync).not.toHaveBeenCalled(); // Should not write on error
  });

  it('should handle filesystem write error gracefully', async () => {
    const fs = await import('fs');

    // Mock fs.writeFileSync to throw error
    vi.mocked(fs.writeFileSync).mockImplementation(() => {
      throw new Error('EACCES: permission denied');
    });

    const response = await agent.chat('/init');

    expect(response).toContain('Error generating CRAFT.md');
    expect(response).toContain('permission denied');
  });

  it('should handle empty function responses', async () => {
    const fs = await import('fs');
    vi.mocked(fs.writeFileSync).mockClear().mockImplementation(() => {});

    // Mock functions to return minimal data
    mockDetectProjectType.mockReturnValue({ type: 'unknown', typescript: false, testFramework: null, linter: null, packageManager: null });
    mockExtractConventions.mockResolvedValue({});
    mockGetProjectOverview.mockReturnValue({ entryPoints: [], sources: [] });

    const response = await agent.chat('/init');

    expect(response).toContain('Project analysis complete');
    expect(fs.writeFileSync).toHaveBeenCalled();

    const content = vi.mocked(fs.writeFileSync).mock.calls[0][1];
    // Should still create valid structure even with minimal data
    expect(content).toContain('## Project Overview');
  });

  // Integration Tests
  it('should format JSON function responses correctly in CRAFT.md', async () => {
    const fs = await import('fs');
    vi.mocked(fs.writeFileSync).mockClear().mockImplementation(() => {});

    // Mock functions to return structured data
    mockDetectProjectType.mockReturnValue({
      type: 'node',
      typescript: true,
      testFramework: 'vitest',
      linter: null,
      packageManager: 'npm'
    });
    mockExtractConventions.mockResolvedValue({
      functionNaming: 'camelCase',
      indentSize: 2
    });
    mockGetProjectOverview.mockReturnValue({
      purpose: 'AI coding agent',
      techStack: { name: 'CodeCraft', languages: ['TypeScript'] },
      entryPoints: [],
      sources: []
    });

    await agent.chat('/init');

    const content = vi.mocked(fs.writeFileSync).mock.calls[0][1];

    // Should not contain "[object Object]"
    expect(content).not.toContain('[object Object]');

    // Should contain actual JSON data (serialized as JSON strings)
    expect(content).toContain('TypeScript');
    expect(content).toContain('camelCase');
    expect(content).toContain('CodeCraft');
  });

  it('should include timestamp in CRAFT.md', async () => {
    const fs = await import('fs');
    vi.mocked(fs.writeFileSync).mockClear().mockImplementation(() => {});

    await agent.chat('/init');

    const content = vi.mocked(fs.writeFileSync).mock.calls[0][1];

    expect(content).toMatch(/Generated by CodeCraft \/init command on \d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/);
  });

  it('should update /help to include /init command', async () => {
    const response = await agent.chat('/help');

    expect(response).toContain('/init');
  });
});
