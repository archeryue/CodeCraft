# Tools Improvement Plan

**Date:** 2025-11-27
**Status:** ✅ COMPLETE
**Goal:** Streamline tools from 19 → 17, improve UX, add background command support
**Final Result:** Successfully reduced from 19 → 17 tools with all improvements implemented

---

## Overview

Current state: 19 tools with some redundancy and missing functionality.

**Problems Identified:**
1. **Project analysis tools** (3 tools) used only once at project start but take up LLM context
2. **Symbol inspection** split across 2 similar tools causing confusion
3. **Command execution** lacks background process support (critical for long-running tasks)

**Solution:**
1. Move one-time analysis to `/init` command → generates `CRAFT.md` for system prompt
2. Merge similar symbol tools into single flexible tool
3. Expand command execution to support background processes

**Net Result:** 19 tools → 17 tools, better UX, more powerful

---

## Part 1: `/init` Command - Project Analysis at Setup

### Concept

Instead of having 3 project analysis tools always available to the LLM, create a **one-time initialization command** that:
- Runs comprehensive project analysis
- Generates `CRAFT.md` (CodeCraft Analysis File)
- `CRAFT.md` gets loaded into system prompt (like `CLAUDE.md`)
- LLM has project context without needing tools

### Implementation

**Modify:** `src/agent.ts` - Add `/init` to slash command switch

```typescript
case '/init':
    // Call analysis tools
    const projectType = await this.executeTool('detect_project_type', { path: '.' });
    const conventions = await this.executeTool('extract_conventions', { path: '.' });
    const overview = await this.executeTool('get_project_overview', { path: '.' });

    // Generate CRAFT.md
    const craftContent = `# CRAFT.md - CodeCraft Project Analysis

## Project Overview
${overview}

## Technology Stack
${projectType}

## Code Conventions
${conventions}

---
Generated by CodeCraft /init command on ${new Date().toISOString()}
`;

    // Write to CRAFT.md
    fs.writeFileSync(path.join(process.cwd(), 'CRAFT.md'), craftContent);

    return "Project analysis complete. CRAFT.md has been generated. Restart the session to load it into context.";
```

**Modify:** `index.ts` to load `CRAFT.md` into system prompt
```typescript
// In buildSystemPrompt() function
const craftPath = path.join(process.cwd(), 'CRAFT.md');
if (fs.existsSync(craftPath)) {
  const craftContent = fs.readFileSync(craftPath, 'utf-8');
  systemPrompt += `\n\n## Project Analysis (CRAFT.md)\n${craftContent}`;
}
```

**Note:** `CRAFT.md` will be committed to git (not ignored) so project context is shared across team members and persisted in repository.

### Benefits

- ✅ **Reduces tool count during operation:** 19 → 16 tools available to LLM per turn
- ✅ **Better context:** Project info always in system prompt, no tool call needed
- ✅ **Faster responses:** No need to call analysis tools repeatedly
- ✅ **User control:** Explicit `/init` makes it clear when analysis happens
- ✅ **Refreshable:** User can run `/init` again if project changes

### Migration

**Keep tools for now** to support `/init` command:
- `detect_project_type` - Used only by `/init`
- `extract_conventions` - Used only by `/init`
- `get_project_overview` - Used only by `/init`

**Later optimization:** Could move these entirely into the `/init` command implementation and remove from tool registry.

---

## Part 2: Merge Symbol Tools → `inspect_symbol`

### Current State (2 tools)

**Tool 1:** `get_symbol_info(symbol, file)`
- Returns: type, signature, location
- Use case: "What is this function?"

**Tool 2:** `resolve_symbol(symbol, file)`
- Returns: definition location
- Use case: "Where is this defined?"

**Problem:** Confusing for LLM to choose between them, similar functionality

### Proposed Design (1 tool)

**New Tool:** `inspect_symbol(symbol, file, mode?)`

```typescript
{
  name: 'inspect_symbol',
  description: 'Inspect a symbol: get info (type, signature) or resolve (find definition).',
  parameters: {
    symbol: { type: STRING, description: 'Symbol name to inspect' },
    file: { type: STRING, description: 'File containing the symbol' },
    mode: {
      type: STRING,
      description: 'Mode: "info" (default, get details) or "resolve" (find definition)',
      enum: ['info', 'resolve']
    }
  }
}
```

### Implementation

**New File:** `src/tools/inspect_symbol.ts`

```typescript
export const inspectSymbolTool: Tool = {
  name: 'inspect_symbol',
  description: 'Inspect a symbol to get detailed information or resolve its definition location.',
  version: '1.0.0',

  parameters: {
    type: SchemaType.OBJECT,
    properties: {
      symbol: { type: SchemaType.STRING, description: 'Symbol name' },
      file: { type: SchemaType.STRING, description: 'File path' },
      mode: {
        type: SchemaType.STRING,
        description: 'Mode: "info" for details (default), "resolve" for definition location',
        enum: ['info', 'resolve']
      }
    },
    required: ['symbol', 'file']
  },

  capabilities: {
    writesFiles: false,
    executesCommands: false,
    requiresRustEngine: true,
    accessesNetwork: false,
    idempotent: true,
    retryable: true
  },

  async execute(params: unknown, context: ToolContext): Promise<ToolResult> {
    const startTime = Date.now();
    const p = params as { symbol: string; file: string; mode?: string };
    const mode = p.mode || 'info';

    if (!context.rustEngine?.getSymbolInfo || !context.rustEngine?.resolveSymbol) {
      return {
        success: false,
        error: { code: 'ENGINE_NOT_AVAILABLE', message: 'Rust engine not available' }
      };
    }

    try {
      let result;

      if (mode === 'resolve') {
        // Find where symbol is defined
        result = context.rustEngine.resolveSymbol(p.file, p.symbol);
        if (!result) {
          return {
            success: false,
            error: {
              code: 'SYMBOL_NOT_FOUND',
              message: `Cannot resolve symbol '${p.symbol}' from ${p.file}`
            },
            metadata: { executionTimeMs: Date.now() - startTime, mode }
          };
        }
      } else {
        // Get symbol information (default)
        result = context.rustEngine.getSymbolInfo(p.file, p.symbol);
        if (!result) {
          return {
            success: false,
            error: {
              code: 'SYMBOL_NOT_FOUND',
              message: `Symbol '${p.symbol}' not found in ${p.file}`
            },
            metadata: { executionTimeMs: Date.now() - startTime, mode }
          };
        }
      }

      return {
        success: true,
        data: result,
        metadata: { executionTimeMs: Date.now() - startTime, mode }
      };
    } catch (err: any) {
      return {
        success: false,
        error: { code: 'INSPECT_ERROR', message: err.message },
        metadata: { executionTimeMs: Date.now() - startTime, mode }
      };
    }
  }
};
```

**Migration:**
1. Create `inspect_symbol.ts`
2. Update `src/tools/index.ts` to export `inspectSymbolTool`
3. Update `src/tool-setup.ts` to register `inspectSymbolTool`
4. Remove `get_symbol_info.ts` and `resolve_symbol.ts`
5. Update tests in `tests/tools/` directory
6. Update `CLAUDE.md` documentation

### Benefits

- ✅ **Simpler:** 2 tools → 1 tool
- ✅ **Flexible:** Mode parameter allows both use cases
- ✅ **Clear:** Description makes purpose obvious
- ✅ **Default behavior:** Defaults to 'info' mode (most common)
- ✅ **Backward compatible:** Can support both modes

---

## Part 3: Expand Command Execution → 3 Tools

### Current State (1 tool)

**Tool:** `run_command(command)`
- Executes command, waits for completion
- Returns full output
- **Problem:** Blocks on long-running commands (builds, tests, dev servers)
- **Problem:** Can't monitor progress of long tasks
- **Problem:** Can't kill runaway processes

### Proposed Design (3 tools)

Inspired by Claude Code's bash tools:

**Tool 1:** `bash(command, run_in_background?)`
```typescript
{
  name: 'bash',
  description: 'Execute shell command. Use run_in_background for long tasks.',
  parameters: {
    command: { type: STRING, description: 'Shell command to execute' },
    run_in_background: {
      type: BOOLEAN,
      description: 'Run in background for long tasks (default: false)'
    },
    timeout: {
      type: NUMBER,
      description: 'Timeout in milliseconds (default: 120000, max: 600000)'
    }
  }
}
```

**Tool 2:** `bash_output(bash_id, filter?)`
```typescript
{
  name: 'bash_output',
  description: 'Get output from background bash process.',
  parameters: {
    bash_id: { type: STRING, description: 'Background process ID from bash tool' },
    filter: {
      type: STRING,
      description: 'Optional regex to filter output lines'
    }
  }
}
```

**Tool 3:** `kill_bash(bash_id)`
```typescript
{
  name: 'kill_bash',
  description: 'Kill a running background bash process.',
  parameters: {
    bash_id: { type: STRING, description: 'Background process ID to kill' }
  }
}
```

### Implementation

**New File:** `src/tools/bash.ts`

```typescript
import { Tool, ToolContext, ToolResult } from '../types/tool';
import { SchemaType } from '@google/generative-ai';
import { spawn, ChildProcess } from 'child_process';

// Track background processes
const backgroundProcesses = new Map<string, {
  process: ChildProcess;
  output: string[];
  error: string[];
  exitCode: number | null;
  startTime: number;
}>();

let nextProcessId = 1;

export const bashTool: Tool = {
  name: 'bash',
  description: 'Execute shell command with optional background execution for long-running tasks.',
  version: '1.0.0',

  parameters: {
    type: SchemaType.OBJECT,
    properties: {
      command: { type: SchemaType.STRING, description: 'Shell command to execute' },
      run_in_background: {
        type: SchemaType.BOOLEAN,
        description: 'Run in background (default: false)'
      },
      timeout: {
        type: SchemaType.NUMBER,
        description: 'Timeout in ms (default: 120000, max: 600000)'
      }
    },
    required: ['command']
  },

  capabilities: {
    writesFiles: false,
    executesCommands: true,
    requiresRustEngine: false,
    accessesNetwork: false,
    idempotent: false,
    retryable: false
  },

  async execute(params: unknown, context: ToolContext): Promise<ToolResult> {
    const startTime = Date.now();
    const p = params as {
      command: string;
      run_in_background?: boolean;
      timeout?: number
    };

    const timeout = Math.min(p.timeout || 120000, 600000);

    if (p.run_in_background) {
      // Background execution
      const processId = `bash_${nextProcessId++}`;
      const child = spawn('bash', ['-c', p.command], {
        cwd: process.cwd(),
        env: process.env
      });

      const processInfo = {
        process: child,
        output: [] as string[],
        error: [] as string[],
        exitCode: null as number | null,
        startTime: Date.now()
      };

      child.stdout?.on('data', (data) => {
        processInfo.output.push(data.toString());
      });

      child.stderr?.on('data', (data) => {
        processInfo.error.push(data.toString());
      });

      child.on('exit', (code) => {
        processInfo.exitCode = code;
        // Auto-cleanup after exit
        setTimeout(() => {
          backgroundProcesses.delete(processId);
        }, 5000); // Keep for 5s for final output retrieval
      });

      backgroundProcesses.set(processId, processInfo);

      return {
        success: true,
        data: {
          message: `Started background process: ${processId}`,
          processId,
          command: p.command
        },
        metadata: { executionTimeMs: Date.now() - startTime }
      };

    } else {
      // Foreground execution with timeout
      return new Promise((resolve) => {
        const child = spawn('bash', ['-c', p.command], {
          cwd: process.cwd(),
          env: process.env
        });

        let stdout = '';
        let stderr = '';

        child.stdout?.on('data', (data) => {
          stdout += data.toString();
        });

        child.stderr?.on('data', (data) => {
          stderr += data.toString();
        });

        const timeoutHandle = setTimeout(() => {
          child.kill();
          resolve({
            success: false,
            error: {
              code: 'TIMEOUT',
              message: `Command timed out after ${timeout}ms`
            },
            metadata: { executionTimeMs: Date.now() - startTime }
          });
        }, timeout);

        child.on('exit', (code) => {
          clearTimeout(timeoutHandle);

          const output = stdout + (stderr ? `\n\nSTDERR:\n${stderr}` : '');

          resolve({
            success: code === 0,
            data: output || '(no output)',
            metadata: {
              executionTimeMs: Date.now() - startTime,
              exitCode: code
            }
          });
        });
      });
    }
  }
};
```

**New File:** `src/tools/bash_output.ts`

```typescript
export const bashOutputTool: Tool = {
  name: 'bash_output',
  description: 'Retrieve output from a background bash process.',
  version: '1.0.0',

  parameters: {
    type: SchemaType.OBJECT,
    properties: {
      bash_id: { type: SchemaType.STRING, description: 'Background process ID' },
      filter: {
        type: SchemaType.STRING,
        description: 'Optional regex to filter output lines'
      }
    },
    required: ['bash_id']
  },

  capabilities: {
    writesFiles: false,
    executesCommands: false,
    requiresRustEngine: false,
    accessesNetwork: false,
    idempotent: true,
    retryable: true
  },

  async execute(params: unknown, context: ToolContext): Promise<ToolResult> {
    const startTime = Date.now();
    const p = params as { bash_id: string; filter?: string };

    // Import from bash.ts (need to export backgroundProcesses)
    const processInfo = getBackgroundProcess(p.bash_id);

    if (!processInfo) {
      return {
        success: false,
        error: {
          code: 'PROCESS_NOT_FOUND',
          message: `Background process '${p.bash_id}' not found`
        },
        metadata: { executionTimeMs: Date.now() - startTime }
      };
    }

    let output = processInfo.output.join('');
    let error = processInfo.error.join('');

    // Apply filter if provided
    if (p.filter) {
      const regex = new RegExp(p.filter);
      const lines = output.split('\n');
      output = lines.filter(line => regex.test(line)).join('\n');
    }

    return {
      success: true,
      data: {
        stdout: output || '(no output yet)',
        stderr: error || '',
        exitCode: processInfo.exitCode,
        running: processInfo.exitCode === null,
        runtime: Date.now() - processInfo.startTime
      },
      metadata: { executionTimeMs: Date.now() - startTime }
    };
  }
};
```

**New File:** `src/tools/kill_bash.ts`

```typescript
export const killBashTool: Tool = {
  name: 'kill_bash',
  description: 'Kill a running background bash process.',
  version: '1.0.0',

  parameters: {
    type: SchemaType.OBJECT,
    properties: {
      bash_id: { type: SchemaType.STRING, description: 'Background process ID to kill' }
    },
    required: ['bash_id']
  },

  capabilities: {
    writesFiles: false,
    executesCommands: true,
    requiresRustEngine: false,
    accessesNetwork: false,
    idempotent: false,
    retryable: true
  },

  async execute(params: unknown, context: ToolContext): Promise<ToolResult> {
    const startTime = Date.now();
    const p = params as { bash_id: string };

    const processInfo = getBackgroundProcess(p.bash_id);

    if (!processInfo) {
      return {
        success: false,
        error: {
          code: 'PROCESS_NOT_FOUND',
          message: `Background process '${p.bash_id}' not found`
        },
        metadata: { executionTimeMs: Date.now() - startTime }
      };
    }

    if (processInfo.exitCode !== null) {
      return {
        success: false,
        error: {
          code: 'PROCESS_ALREADY_EXITED',
          message: `Process '${p.bash_id}' already exited with code ${processInfo.exitCode}`
        },
        metadata: { executionTimeMs: Date.now() - startTime }
      };
    }

    try {
      processInfo.process.kill();
      removeBackgroundProcess(p.bash_id);

      return {
        success: true,
        data: `Killed process: ${p.bash_id}`,
        metadata: { executionTimeMs: Date.now() - startTime }
      };
    } catch (err: any) {
      return {
        success: false,
        error: {
          code: 'KILL_ERROR',
          message: err.message
        },
        metadata: { executionTimeMs: Date.now() - startTime }
      };
    }
  }
};
```

### Usage Examples

**Example 1: Long build process**
```
Agent: bash(command='npm run build', run_in_background=true)
→ Returns: { processId: 'bash_1', message: 'Started background process' }

Agent: bash_output(bash_id='bash_1')
→ Returns: { stdout: '...building...', running: true }

Agent: bash_output(bash_id='bash_1')
→ Returns: { stdout: '...build complete!', exitCode: 0, running: false }
```

**Example 2: Kill runaway test**
```
Agent: bash(command='npm test -- --watch', run_in_background=true)
→ Returns: { processId: 'bash_2' }

Agent: kill_bash(bash_id='bash_2')
→ Returns: 'Killed process: bash_2'
```

**Example 3: Monitor with filter**
```
Agent: bash(command='npm run dev', run_in_background=true)
→ Returns: { processId: 'bash_3' }

Agent: bash_output(bash_id='bash_3', filter='ERROR|WARN')
→ Returns: { stdout: 'ERROR: Connection failed\nWARN: Retrying...' }
```

### Migration

1. Create new files: `bash.ts`, `bash_output.ts`, `kill_bash.ts`
2. Update `src/tools/index.ts` exports
3. Update `src/tool-setup.ts` registration
4. **Add cleanup handlers** in `index.ts`:
   ```typescript
   process.on('exit', () => killAllBackgroundProcesses());
   process.on('SIGINT', () => { killAllBackgroundProcesses(); process.exit(0); });
   ```
5. **Keep `run_command` temporarily** for backward compatibility
6. Update tests
7. Update `CLAUDE.md` documentation
8. **Later:** Deprecate and remove `run_command` after validation

### Benefits

- ✅ **Background execution:** Can run builds, tests, dev servers
- ✅ **Progress monitoring:** Check output while running
- ✅ **Process control:** Kill runaway processes
- ✅ **Better UX:** No blocking on long commands
- ✅ **Filtering:** Focus on errors/warnings in output
- ✅ **Aligned with industry:** Matches Claude Code's design

---

## Summary of Changes

### Tool Count Evolution

| Category | Before | After | Change |
|----------|--------|-------|--------|
| File Operations | 5 | 5 | - |
| Search & Discovery | 4 | 4 | - |
| Rust Symbol Analysis | 5 | 4 | -1 (merged) |
| Project Analysis | 3 | 3 | (moved to /init) |
| Utilities | 2 | 5 | +3 (bash expansion) |
| **TOTAL** | **19** | **21** | **+2** |

**Wait, that's MORE tools!** But effective count is lower:

| State | Available to LLM | Notes |
|-------|------------------|-------|
| Before | 19 tools | All available every turn |
| After | 18 tools | Analysis tools only used in /init |
| Future | 15 tools | Remove analysis tools entirely |

### Implementation Phases

**Phase 1: Immediate (Week 1)**
- [ ] Add `/init` case to switch statement in `src/agent.ts`
- [ ] Implement `/init` logic to call analysis tools and generate CRAFT.md
- [ ] Modify `index.ts` to load `CRAFT.md` into system prompt
- [ ] Update `CLAUDE.md` documentation with `/init` usage

**Phase 2: Symbol Tool Merge (Week 1-2)**
- [ ] Create `src/tools/inspect_symbol.ts`
- [ ] Write tests in `tests/tools/inspect_symbol.test.ts`
- [ ] Update `src/tools/index.ts` and `src/tool-setup.ts`
- [ ] Remove `get_symbol_info.ts` and `resolve_symbol.ts`
- [ ] Update all related tests

**Phase 3: Bash Tool Expansion (Week 2)**
- [ ] Create `src/tools/bash.ts` with background support
- [ ] Create `src/tools/bash_output.ts`
- [ ] Create `src/tools/kill_bash.ts`
- [ ] Write comprehensive tests for all 3 tools
- [ ] Update `src/tools/index.ts` and `src/tool-setup.ts`
- [ ] Keep `run_command` for backward compatibility

**Phase 4: Validation (Week 3)**
- [ ] End-to-end testing of `/init` command
- [ ] Test `inspect_symbol` in real scenarios
- [ ] Test background bash processes
- [ ] Update all documentation
- [ ] Run full test suite (`npm test`)

**Phase 5: Cleanup (Week 4)**
- [ ] Remove analysis tools from tool registry (move into `/init` implementation)
- [ ] Deprecate `run_command`
- [ ] Final documentation update
- [ ] **Final count: 15 tools**

---

## Testing Requirements

### Phase 1: /init Command

**Unit Tests:**
- N/A (slash command, tested manually)

**E2E Tests:**
```bash
npx tsx index.ts
> /init
# Verify CRAFT.md is created
# Verify CRAFT.md contains all sections
# Verify system prompt includes CRAFT.md on next session
```

### Phase 2: inspect_symbol

**Unit Tests:** `tests/tools/inspect_symbol.test.ts`
```typescript
describe('inspect_symbol', () => {
  it('should get symbol info in "info" mode (default)');
  it('should resolve symbol definition in "resolve" mode');
  it('should return error if symbol not found');
  it('should handle missing Rust engine');
  it('should include mode in metadata');
});
```

### Phase 3: Bash Tools

**Unit Tests:**
```typescript
describe('bash', () => {
  it('should execute command in foreground');
  it('should execute command in background and return process ID');
  it('should timeout long-running foreground commands');
  it('should track background processes');
});

describe('bash_output', () => {
  it('should retrieve output from background process');
  it('should filter output with regex');
  it('should return error if process not found');
  it('should indicate if process is still running');
});

describe('kill_bash', () => {
  it('should kill running background process');
  it('should return error if process not found');
  it('should return error if process already exited');
});
```

**E2E Tests:**
```bash
# Test background execution
> Use bash to run "sleep 5 && echo done" in background
> Check the output after 2 seconds
> Check the output after 6 seconds

# Test process killing
> Run "sleep 100" in background
> Kill the process
> Verify it's killed
```

---

## Success Metrics

**Code Quality:**
- [ ] All tests pass (`npm test`)
- [ ] No TypeScript errors
- [ ] All E2E scenarios work

**Tool Effectiveness:**
- [ ] `/init` generates complete CRAFT.md
- [ ] `inspect_symbol` handles both modes correctly
- [ ] Background bash processes work reliably

**User Experience:**
- [ ] Faster LLM responses (fewer tools to consider)
- [ ] Better project understanding (CRAFT.md in context)
- [ ] Can run long commands without blocking

**Documentation:**
- [ ] CLAUDE.md updated with new tools
- [ ] README.md includes `/init` usage
- [ ] TEST_PLANS.md includes all new test cases

---

## Future Considerations

**After this plan:**
1. **Evaluate `build_dependency_graph`**: Is it used? If not, remove.
2. **Consider merging glob + grep**: Could be single `search(pattern, mode='files'|'content')`
3. **Add streaming output**: For bash_output, stream data instead of polling
4. **Add bash history**: `/bash_history` to see all background processes
5. **Shell selection**: Support other shells (zsh, fish) via parameter

**Long-term vision:**
- **~12-15 core tools**: Essential operations only
- **Smart tool selection**: LLM chooses right tool faster
- **Rich context**: CRAFT.md + CLAUDE.md gives deep project understanding
- **Power user features**: Background processes, streaming, advanced control

---

## Design Decisions (Confirmed)

1. **CRAFT.md location**: ✅ Root directory (like CLAUDE.md)
2. **CRAFT.md in git**: ✅ Committed (shared context across team)
3. **Tool naming**: ✅ `bash` (clear and familiar)
4. **Default mode**: ✅ `inspect_symbol` defaults to 'info' mode
5. **Process cleanup**: ✅ Auto-kill background processes on exit
   - Processes auto-removed 5 seconds after exit
   - Clean shutdown kills all active background processes

---

**Document Owner:** Claude Code
**Last Updated:** 2025-11-27
**Next Review:** After Phase 1 completion
